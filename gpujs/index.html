<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GPU.js Boids Simulation</title>
  <script src="https://cdn.jsdelivr.net/npm/gpu.js@2.11.0/dist/gpu-browser.min.js"></script>
  <style>
    body {
      margin: 0;
      background-color: black;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="boidsCanvas"></canvas>
  <script>
    const canvas = document.getElementById('boidsCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // GPU.js setup
    const GPUJS = GPU.GPU || GPU;
    const gpu = new GPUJS();

    // Parameters
    const numBoids = 500;
    const boundary = 500;
    const maxSpeed = 4;
    const perceptionRadius = 50;

    // Initialize boid positions and velocities
    const positions = new Float32Array(numBoids * 3);
    const velocities = new Float32Array(numBoids * 3);

    for (let i = 0; i < numBoids; i++) {
      positions[i * 3] = Math.random() * boundary * 2 - boundary;
      positions[i * 3 + 1] = Math.random() * boundary * 2 - boundary;
      positions[i * 3 + 2] = Math.random() * boundary * 2 - boundary;
      velocities[i * 3] = Math.random() * 2 - 1;
      velocities[i * 3 + 1] = Math.random() * 2 - 1;
      velocities[i * 3 + 2] = Math.random() * 2 - 1;
    }

    // GPU Kernel to update boids
    const updateBoidsKernel = gpu
      .createKernel(function (positions, velocities, numBoids, boundary, maxSpeed, perceptionRadius) {
        const index = this.thread.x;
        const px = positions[index * 3];
        const py = positions[index * 3 + 1];
        const pz = positions[index * 3 + 2];
        const vx = velocities[index * 3];
        const vy = velocities[index * 3 + 1];
        const vz = velocities[index * 3 + 2];

        let ax = 0, ay = 0, az = 0;
        let cx = 0, cy = 0, cz = 0;
        let sx = 0, sy = 0, sz = 0;
        let count = 0;

        for (let i = 0; i < numBoids; i++) {
          if (i !== index) {
            const ox = positions[i * 3];
            const oy = positions[i * 3 + 1];
            const oz = positions[i * 3 + 2];
            const dx = px - ox;
            const dy = py - oy;
            const dz = pz - oz;
            const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);

            if (distance < perceptionRadius) {
              ax += velocities[i * 3];
              ay += velocities[i * 3 + 1];
              az += velocities[i * 3 + 2];

              cx += ox;
              cy += oy;
              cz += oz;

              sx += dx / distance;
              sy += dy / distance;
              sz += dz / distance;

              count++;
            }
          }
        }

        if (count > 0) {
          ax /= count;
          ay /= count;
          az /= count;

          cx /= count;
          cy /= count;
          cz /= count;

          cx = (cx - px) * 0.05;
          cy = (cy - py) * 0.05;
          cz = (cz - pz) * 0.05;

          sx /= count;
          sy /= count;
          sz /= count;
        }

        let nvx = vx + ax + cx + sx;
        let nvy = vy + ay + cy + sy;
        let nvz = vz + az + cz + sz;

        const speed = Math.sqrt(nvx * nvx + nvy * nvy + nvz * nvz);
        if (speed > maxSpeed) {
          nvx = (nvx / speed) * maxSpeed;
          nvy = (nvy / speed) * maxSpeed;
          nvz = (nvz / speed) * maxSpeed;
        }

        let nx = px + nvx;
        let ny = py + nvy;
        let nz = pz + nvz;

        // Boundary wrapping
        nx = nx < -boundary ? nx + boundary * 2 : nx > boundary ? nx - boundary * 2 : nx;
        ny = ny < -boundary ? ny + boundary * 2 : ny > boundary ? ny - boundary * 2 : ny;
        nz = nz < -boundary ? nz + boundary * 2 : nz > boundary ? nz - boundary * 2 : nz;

        // Return updated position and velocity
        return { nx, ny, nz, nvx, nvy, nvz };

      })
      .setOutput({ nx: 512, ny: 512, nz: 512, nvx: 512, nvy: 512, nvz: 512 });

    function updateBoids() {
      // Update boids using GPU.js kernel
      const results = updateBoidsKernel(positions, velocities, numBoids, boundary, maxSpeed, perceptionRadius);

      // Transfer results back to positions and velocities
      for (let i = 0; i < numBoids; i++) {
        positions[i * 3] = results[i][0];
        positions[i * 3 + 1] = results[i][1];
        positions[i * 3 + 2] = results[i][2];
        velocities[i * 3] = results[i][3];
        velocities[i * 3 + 1] = results[i][4];
        velocities[i * 3 + 2] = results[i][5];
      }
    }

    function drawBoids() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (let i = 0; i < numBoids; i++) {
        const x = positions[i * 3] + canvas.width / 2;
        const y = positions[i * 3 + 1] + canvas.height / 2;

        ctx.beginPath();
        ctx.arc(x, y, 3, 0, Math.PI * 2);
        ctx.fillStyle = "white";
        ctx.fill();
      }
    }

    function animate() {
      updateBoids();
      drawBoids();
      requestAnimationFrame(animate);
    }

    animate();
  </script>
</body>
</html>