<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Boids with Three.js</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
        #stats { position: absolute; bottom: 10px; left: 10px; z-index: 100; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/16/Stats.min.js"></script>
    <script>
        // Set up the scene, camera, and renderer
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // FPS counter setup
        const stats = new Stats();
        stats.showPanel(0); // 0: FPS, 1: MS, 2: Memory
        document.body.appendChild(stats.dom);

        // Boid class
        class Boid {
            constructor(x, y, z) {
                this.position = new THREE.Vector3(x, y, z);
                this.velocity = new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();
                this.acceleration = new THREE.Vector3(0, 0, 0);
                this.maxSpeed = 0.1;
                this.maxForce = 0.02;

                // Create the boid geometry and material
                const geometry = new THREE.ConeGeometry(0.2, 1, 6);
                const material = new THREE.MeshBasicMaterial({ color: Math.random() * 0xffffff });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.rotation.x = Math.PI / 2;
                scene.add(this.mesh);
            }

            // Update position and velocity based on behavior
            update(boids) {
                this.flock(boids);
                this.velocity.add(this.acceleration);
                this.velocity.clampLength(0, this.maxSpeed);
                this.position.add(this.velocity);
                this.acceleration.set(0, 0, 0);

                // Keep boid inside bounds
                if (this.position.x > 5) this.position.x = -5;
                if (this.position.x < -5) this.position.x = 5;
                if (this.position.y > 5) this.position.y = -5;
                if (this.position.y < -5) this.position.y = 5;
                if (this.position.z > 5) this.position.z = -5;
                if (this.position.z < -5) this.position.z = 5;

                // Update mesh position
                this.mesh.position.copy(this.position);
                this.mesh.lookAt(this.position.add(this.velocity));
            }

            // Flocking behavior
            flock(boids) {
                const alignment = this.align(boids);
                const cohesion = this.cohere(boids);
                const separation = this.separate(boids);

                alignment.multiplyScalar(1.0);
                cohesion.multiplyScalar(1.0);
                separation.multiplyScalar(1.5);

                this.acceleration.add(alignment);
                this.acceleration.add(cohesion);
                this.acceleration.add(separation);
            }

            // Align with neighbors
            align(boids) {
                const steering = new THREE.Vector3();
                let total = 0;
                for (const boid of boids) {
                    const distance = this.position.distanceTo(boid.position);
                    if (boid !== this && distance < 3) {
                        steering.add(boid.velocity);
                        total++;
                    }
                }
                if (total > 0) {
                    steering.divideScalar(total);
                    steering.normalize();
                    steering.multiplyScalar(this.maxSpeed);
                    steering.sub(this.velocity);
                    steering.clampLength(0, this.maxForce);
                }
                return steering;
            }

            // Move towards the center of mass of neighbors
            cohere(boids) {
                const steering = new THREE.Vector3();
                let total = 0;
                for (const boid of boids) {
                    const distance = this.position.distanceTo(boid.position);
                    if (boid !== this && distance < 3) {
                        steering.add(boid.position);
                        total++;
                    }
                }
                if (total > 0) {
                    steering.divideScalar(total);
                    steering.sub(this.position);
                    steering.normalize();
                    steering.multiplyScalar(this.maxSpeed);
                    steering.sub(this.velocity);
                    steering.clampLength(0, this.maxForce);
                }
                return steering;
            }

            // Avoid collisions with neighbors
            separate(boids) {
                const steering = new THREE.Vector3();
                let total = 0;
                for (const boid of boids) {
                    const distance = this.position.distanceTo(boid.position);
                    if (boid !== this && distance < 1) {
                        const diff = new THREE.Vector3().subVectors(this.position, boid.position);
                        diff.normalize();
                        diff.divideScalar(distance);
                        steering.add(diff);
                        total++;
                    }
                }
                if (total > 0) {
                    steering.divideScalar(total);
                    steering.normalize();
                    steering.multiplyScalar(this.maxSpeed);
                    steering.sub(this.velocity);
                    steering.clampLength(0, this.maxForce);
                }
                return steering;
            }
        }

        // Create an array of boids
        const boids = [];
        for (let i = 0; i < 1000; i++) {
            boids.push(new Boid(Math.random() * 10 - 5, Math.random() * 10 - 5, Math.random() * 10 - 5));
        }

        // Animation loop
        function animate() {
            stats.begin(); // Start measuring performance

            boids.forEach(boid => boid.update(boids));

            renderer.render(scene, camera);

            stats.end(); // End measuring performance

            requestAnimationFrame(animate);
        }

        // Set up the camera position
        camera.position.z = 5;

        // Start the animation
        animate();
    </script>
</body>
</html>